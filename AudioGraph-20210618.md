# AudioGraph

## 前情提要
在上一篇笔记中，我花了一点时间，让程序输出了 2 秒的正弦波，结果程序能够运行，但我还是发现了一些小问题。

此笔记中写了一些对这些问题的观察和部分解决方法，有些问题还没有得到解决。

*注：此笔记中的采样数均为单个声道的值。*

### 1. 输出的采样数貌似不太对？
笔者初次运行时，使用的电脑声卡的采样率为 44100 Hz。如果要保证输出的时间为 2s，则采样数必须为  
44100 × 2 = 88200（采样）

在 Debug x64 配置下生成应用程序并运行（不调试），其中一次部分输出如下：
```
89,152
```
这个数字是实际输出的采样数（`outputSampleCount`）。显然输出正弦波的时间要比预期的长。  
这一问题的*部分*原因是我之前没有注意到的：我的代码对输出时间控制并不准确。  
我在代码中使用的睡眠方法是标准库中的 `std::this_thread::sleep_for`。<a href="https://zh.cppreference.com/w/cpp/thread/sleep_for">cppreference 中对这一方法的的说明</a> 如下：
> 阻塞当前线程执行，至少经过指定的 `sleep_duration` 。  
此函数可能阻塞长于 `sleep_duration` ，因为调度或资源争议延迟。 

实际上，在数字音频相关的程序设计中，使用锁和阻塞方式进行计时等待操作很容易出现时间不一致的问题。这种场景下，用无锁数据结构和忙等待的方式更好。

于是我将之前的计时等待操作改成了忙等待：
```cpp
while (outputSampleCount < encodingProperties.SampleRate() * 2/*时间，以秒为单位*/) {} // 忙等待
```
另一个问题是这样的：输出的采样数永远不小于 88200，且拥有一个共同点：它们都能够被缓冲区的采样数（`requiredSamples`）整除。部分输出如下：
```
Output sample count: 88,256
Buffer size: 448
Ideal buffer count: 196.875
Actual buffer count: 197
```
这是因为输出是以缓冲区为单位进行的。
笔者随后将采样率切换到 48000Hz，再次进行测试，部分输出如下：
```
Output sample count: 96,000
Buffer size: 480
Ideal buffer count: 200
Actual buffer count: 200
```
由于要输出的采样个数能被缓冲区大小整除，所以此处的实际输出与所需的采样数相等。

### 2. 回放内容貌似也不太对？

另一个是回放时的问题。程序在启动 `graph` 后立即启动 `frameInput`，则输出的音频在开头一小段时间按预定的振幅输出，之后振幅突然变小，然后振幅回复到略低于预定振幅的值。
若选择在启动 `graph` 后等待 500ms 左右，再启动 `frameInput`，则输出的音频振幅总体上符合预定值。